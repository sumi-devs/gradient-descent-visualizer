#!/usr/bin/env python3
"""
Python implementation of Plotly.js numFormat function.

This module provides a faithful Python translation of the numFormat function 
from src/plots/cartesian/axes.js, maintaining the same logic and behavior.

Key features implemented:
- All exponent format types (e, E, SI, B, power, none, hide)
- Precision rounding with positive, zero, and negative tick rounding
- SI prefix handling with proper range validation
- Thousands separator and decimal point formatting
- Hover mode with increased precision
- Proper Unicode minus sign handling
- Zero threshold (epsilon) handling

Limitations of this implementation:
- Custom tick format support is simplified (doesn't use D3 formatting)
- autoTickRound function is simplified compared to the full Plotly.js version
- tickformatstops processing is not implemented in get_tick_format
"""

import re
import math
from typing import Union, Optional, Dict, Any


# Constants
MINUS_SIGN = '−'  # Unicode minus sign (U+2212)
SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T']
SI_INDEX_OFFSET = 5
HOVER_PRECISION_BONUS = 4
SI_MAX_EXP = 14
SI_MIN_EXP = -15


def is_numeric(value):
    """Check if a value is numeric (equivalent to fast-isnumeric)."""
    try:
        num = float(value)
        return not math.isnan(num)
    except (ValueError, TypeError):
        return False


def is_si_format(exponent_format):
    """Check if exponent format is SI or B."""
    return exponent_format in ('SI', 'B')


def beyond_si(exponent):
    """Check if exponent is beyond SI prefix range."""
    return exponent > SI_MAX_EXP or exponent < SI_MIN_EXP


def num_separate(value, separators, separate_thousands=False):
    """
    Apply decimal and thousands separators to a number string.
    
    Args:
        value: Number as string
        separators: String where first char is decimal sep, second is thousands sep
        separate_thousands: Whether to separate thousands for 4-digit integers
    
    Returns:
        Formatted string with separators applied
    """
    if not isinstance(separators, str) or len(separators) == 0:
        raise ValueError('Separator string required for formatting!')
    
    if isinstance(value, (int, float)):
        value = str(value)
    
    decimal_sep = separators[0] if separators else '.'
    thou_sep = separators[1] if len(separators) > 1 else ''
    
    # Split on decimal point
    parts = value.split('.')
    integer_part = parts[0]
    decimal_part = ('.' + parts[1]) if len(parts) > 1 else ''
    
    # Apply thousands separator
    if thou_sep and (len(parts) > 1 or len(integer_part) > 4 or separate_thousands):
        integer_part = re.sub(r'(\d)(?=(\d{3})+(?!\d))', rf'\1{thou_sep}', integer_part)
    
    # Replace decimal point if needed
    if decimal_part and decimal_sep != '.':
        decimal_part = decimal_sep + decimal_part[1:]
    
    return integer_part + decimal_part


def auto_tick_round(ax_config):
    """
    Calculate tick rounding and exponent for an axis configuration.
    This is a simplified version of the autoTickRound function.
    """
    dtick = ax_config.get('dtick', 1)
    ax_config['_tickexponent'] = 0
    
    if not is_numeric(dtick) and not isinstance(dtick, str):
        dtick = 1
    
    ax_type = ax_config.get('type', 'linear')
    if ax_type in ['category', 'multicategory']:
        ax_config['_tickround'] = None
        return
    
    # Simplified logic - in real implementation this would be more complex
    if isinstance(dtick, str):
        ax_config['_tickround'] = 0
    elif dtick >= 1:
        ax_config['_tickround'] = 0
    else:
        ax_config['_tickround'] = -math.floor(math.log10(dtick))


def get_tick_format(ax):
    """
    Get tick format from axis configuration.
    Simplified version - real implementation handles tickformatstops.
    """
    return ax.get('tickformat') or ax.get('hoverformat')


def apply_rounding(value, tick_round):
    """Apply rounding based on tick_round value."""
    if tick_round == 0:
        return str(int(math.floor(value)))
    elif tick_round < 0:
        rounded = str(int(round(value)))
        return rounded[:len(rounded) + tick_round] + '0' * (-tick_round)
    else:
        value_str = str(value)
        if '.' in value_str:
            dp_pos = value_str.find('.') + 1
            value_str = value_str[:dp_pos + tick_round]
            return re.sub(r'\.?0+$', '', value_str)
        return value_str


def format_exponent(value, exponent, exponent_format):
    """Format a value with its exponent based on the specified format."""
    if not exponent or exponent_format == 'hide':
        return value
        
    if is_si_format(exponent_format) and beyond_si(exponent):
        exponent_format = 'power'
    
    # Format exponent sign
    if exponent < 0:
        signed_exponent = f'{MINUS_SIGN}{-exponent}'
    elif exponent_format != 'power':
        signed_exponent = f'+{exponent}'
    else:
        signed_exponent = str(exponent)
    
    # Apply format-specific suffix
    if exponent_format in ['e', 'E']:
        return value + f'{exponent_format}{signed_exponent}'
    elif exponent_format == 'power':
        return value + f'×10<sup>{signed_exponent}</sup>'
    elif exponent_format == 'B' and exponent == 9:
        return value + 'B'
    elif is_si_format(exponent_format):
        # Use SI prefix from array
        prefix_index = exponent // 3 + SI_INDEX_OFFSET
        if 0 <= prefix_index < len(SIPREFIXES):
            return value + SIPREFIXES[prefix_index]
    
    return value


def num_format(v: float, ax: Dict[str, Any], fmtoverride: Optional[str] = None, hover: bool = False) -> str:
    """
    Format a numerical value for display on Plotly.js axes.
    
    Args:
        v: The numerical value to format
        ax: Axis configuration object containing formatting settings
        fmtoverride: Override for the exponent format setting
        hover: Whether this is for hover display (enables special hover formatting)
    
    Returns:
        Formatted number as string ready for display
    """
    # 1. Initial setup and parameter extraction
    is_neg = v < 0
    tick_round = ax.get('_tickround', 0)
    exponent_format = fmtoverride or ax.get('exponentformat', 'B')
    exponent = ax.get('_tickexponent', 0)
    tickformat = get_tick_format(ax)
    separate_thousands = ax.get('separatethousands', False)
    
    # 2. Special hover mode processing
    if hover:
        dtick = ax.get('dtick', 1) if ax.get('showexponent') == 'none' else (abs(v) or 1 if is_numeric(v) else 1)
        range_val = ax.get('range', [0, 1]) if ax.get('showexponent') == 'none' else [0, v or 1]
        hover_axis_config = {
            'exponentformat': exponent_format,
            'minexponent': ax.get('minexponent', 0),
            'dtick': dtick,
            'range': range_val
        }
        auto_tick_round(hover_axis_config)
        tick_round = (hover_axis_config.get('_tickround') or 0) + HOVER_PRECISION_BONUS
        exponent = hover_axis_config.get('_tickexponent', 0)
        if ax.get('hoverformat'):
            tickformat = ax.get('hoverformat')
    
    # 3. Custom tick format handling
    if tickformat:
        # In a full implementation, this would use ax._numFormat
        # For now, return a basic formatted version
        formatted = str(v).replace('-', MINUS_SIGN)
        return formatted
    
    # 4. Epsilon calculation and near-zero handling
    epsilon = math.pow(10, -tick_round) / 2 if tick_round is not None else 0.5
    
    if abs(v) < epsilon:
        v = '0'
        is_neg = False
        exponent = 0  # Zero should not have exponent formatting
    else:
        # 5. Exponent format processing
        if exponent_format == 'none':
            exponent = 0
        
        # 6. Main number processing (non-zero values)
        v = abs(v)
        v += epsilon  # Add epsilon for proper rounding
        
        # Apply exponent scaling
        if exponent:
            v *= math.pow(10, -exponent)
            tick_round += exponent
        
        # 7. Precision rounding logic
        v = apply_rounding(v, tick_round)
        
        # 8. Thousands separator application
        separators = ax.get('_separators', '.,')
        v = num_separate(v, separators, separate_thousands)
    
    # 9. Exponent formatting application
    v = format_exponent(v, exponent, exponent_format)
    
    # 10. Final sign application
    if is_neg:
        return f'{MINUS_SIGN}{v}'
    return v


# Example usage and test cases
if __name__ == '__main__':
    print("Testing numFormat function:")
    
    # Test basic functionality
    ax_config = {
        '_tickround': 2,
        'exponentformat': 'SI',
        '_tickexponent': 0,
        'separatethousands': True,
        '_separators': '.,'
    }
    
    print("\nBasic formatting:")
    print(f"1234.567 -> {num_format(1234.567, ax_config)}")
    print(f"0.001234 -> {num_format(0.001234, ax_config)}")
    print(f"1000000 -> {num_format(1000000, ax_config)}")
    print(f"-42.0 -> {num_format(-42.0, ax_config)}")
    
    # Test with exponents
    print("\nWith SI exponents:")
    ax_config['_tickexponent'] = 3
    print(f"1234567 with exp 3 -> {num_format(1234567, ax_config)}")
    ax_config['_tickexponent'] = 6
    print(f"1234567 with exp 6 -> {num_format(1234567, ax_config)}")
    
    # Test different exponent formats
    print("\nDifferent exponent formats:")
    ax_config['_tickexponent'] = 3
    formats = ['e', 'E', 'power', 'B', 'none', 'hide']
    for fmt in formats:
        ax_config['exponentformat'] = fmt
        result = num_format(1234567, ax_config)
        print(f"Format '{fmt}': {result}")
    
    # Test hover mode
    print("\nHover mode:")
    ax_config = {'_tickround': 2, 'exponentformat': 'SI', '_tickexponent': 0}
    print(f"Normal: {num_format(1234.567, ax_config)}")
    print(f"Hover:  {num_format(1234.567, ax_config, hover=True)}")
    
    # Test negative rounding
    print("\nNegative rounding:")
    ax_config = {'_tickround': -2, 'exponentformat': 'none', '_tickexponent': 0, '_separators': '.,'}
    print(f"12345 with tickRound -2 -> {num_format(12345, ax_config)}")
    
    # Test zero handling
    print("\nZero handling:")
    ax_config = {'_tickround': 2, 'exponentformat': 'SI', '_tickexponent': 3}
    print(f"0 -> {num_format(0, ax_config)}")
    print(f"0.0001 -> {num_format(0.0001, ax_config)}")
    print(f"-0.0001 -> {num_format(-0.0001, ax_config)}")