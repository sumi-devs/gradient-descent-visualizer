# numFormat Function Documentation

## Overview

The `numFormat` function is responsible for formatting numerical values for display on Plotly.js axes. It handles various formatting styles including scientific notation, SI prefixes, thousands separators, decimal precision, and special hover formatting.

## Function Signature

```javascript
function numFormat(v, ax, fmtoverride, hover)
```

### Parameters

- **`v`** (number): The numerical value to format
- **`ax`** (object): The axis configuration object containing formatting settings
- **`fmtoverride`** (string, optional): Override for the exponent format setting
- **`hover`** (boolean, optional): Whether this is for hover display (enables special hover formatting)

### Returns

- **string**: The formatted number as a string ready for display

## Core Logic Flow

### 1. Initial Setup and Parameter Extraction

```javascript
var isNeg = v < 0;
var tickRound = ax._tickround;
var exponentFormat = fmtoverride || ax.exponentformat || 'B';
var exponent = ax._tickexponent;
var tickformat = axes.getTickFormat(ax);
var separatethousands = ax.separatethousands;
```

**Key Points:**
- Stores the sign of the original number for later restoration
- Extracts rounding precision from axis configuration
- Determines exponent format with fallback hierarchy: `fmtoverride` → `ax.exponentformat` → `'B'`
- Gets tick format from axis settings (may include tickformatstops)

### 2. Special Hover Mode Processing

When `hover` parameter is `true`:

```javascript
if(hover) {
    var ah = {
        exponentformat: exponentFormat,
        minexponent: ax.minexponent,
        dtick: ax.showexponent === 'none' ? ax.dtick : (isNumeric(v) ? Math.abs(v) || 1 : 1),
        range: ax.showexponent === 'none' ? ax.range.map(ax.r2d) : [0, v || 1]
    };
    autoTickRound(ah);
    tickRound = (Number(ah._tickround) || 0) + 4;
    exponent = ah._tickexponent;
    if(ax.hoverformat) tickformat = ax.hoverformat;
}
```

**Hover Mode Behavior:**
- Creates a temporary axis object to calculate precision specifically for the hover value
- Adds 4 extra digits of precision beyond normal tick labels
- Uses `ax.hoverformat` if specified
- Handles the `showexponent === 'none'` case by preserving original dtick and range

### 3. Custom Tick Format Handling

```javascript
if(tickformat) return ax._numFormat(tickformat)(v).replace(/-/g, MINUS_SIGN);
```

**Early Return Condition:**
- If a custom tick format is specified, uses the axis's number formatter
- Replaces standard minus signs (`-`) with proper minus signs (`MINUS_SIGN`)
- Bypasses all other formatting logic

### 4. Epsilon Calculation and Near-Zero Handling

```javascript
var e = Math.pow(10, -tickRound) / 2;
if(v < e) {
    v = '0';
    isNeg = false;
}
```

**Zero Threshold Logic:**
- Calculates epsilon as half of the smallest displayable increment
- Values smaller than epsilon are treated as exactly zero
- Ensures zero is never displayed as negative

### 5. Exponent Format Processing

```javascript
if(exponentFormat === 'none') exponent = 0;
```

**Exponent Format Options:**
- `'e'`: Standard scientific notation (1.2e+6)
- `'E'`: Uppercase scientific notation (1.2E+6) 
- `'SI'`: SI prefixes (1.2M)
- `'B'`: SI prefixes with 10^9 = B instead of G
- `'none'`: No exponent formatting (1200000)
- `'power'`: Power notation (1.2×10^6)
- `'hide'`: Hide exponent (1.2)

### 6. Main Number Processing (Non-Zero Values)

```javascript
v = Math.abs(v);
v += e;  // Add epsilon for proper rounding

if(exponent) {
    v *= Math.pow(10, -exponent);
    tickRound += exponent;
}
```

**Steps:**
1. Convert to absolute value (sign handled separately)
2. Add epsilon to ensure proper rounding behavior
3. If exponent exists, scale the value and adjust rounding precision

### 7. Precision Rounding Logic

Three distinct rounding cases based on `tickRound`:

#### Case 1: No Decimal Places (`tickRound === 0`)
```javascript
if(tickRound === 0) v = String(Math.floor(v));
```
- Simple floor operation, no decimal point

#### Case 2: Negative Rounding (`tickRound < 0`)
```javascript
else if(tickRound < 0) {
    v = String(Math.round(v));
    v = v.substr(0, v.length + tickRound);
    for(var i = tickRound; i < 0; i++) v += '0';
}
```
- Rounds to nearest integer then truncates digits
- Pads with zeros to achieve desired precision
- Example: `tickRound = -2` converts 1234 → 1200

#### Case 3: Positive Rounding (`tickRound > 0`)
```javascript
else {
    v = String(v);
    var dp = v.indexOf('.') + 1;
    if(dp) v = v.substr(0, dp + tickRound).replace(/\.?0+$/, '');
}
```
- Truncates to specified decimal places
- Removes trailing zeros and unnecessary decimal point
- Example: `tickRound = 2` converts 1.2000 → 1.2

### 8. Thousands Separator Application

```javascript
v = Lib.numSeparate(v, ax._separators, separatethousands);
```

**Lib.numSeparate Logic:**
- Uses `ax._separators` string where first character is decimal separator, second is thousands separator
- Only applies thousands separator if:
  - `separatethousands` is true, OR
  - Number has decimal places, OR
  - Integer part has more than 4 digits
- Years (4-digit integers) are not separated unless explicitly enabled

### 9. Exponent Formatting Application

```javascript
if(exponent && exponentFormat !== 'hide') {
    if(isSIFormat(exponentFormat) && beyondSI(exponent)) exponentFormat = 'power';
    
    var signedExponent;
    if(exponent < 0) signedExponent = MINUS_SIGN + -exponent;
    else if(exponentFormat !== 'power') signedExponent = '+' + exponent;
    else signedExponent = String(exponent);
    
    if(exponentFormat === 'e' || exponentFormat === 'E') {
        v += exponentFormat + signedExponent;
    } else if(exponentFormat === 'power') {
        v += '×10<sup>' + signedExponent + '</sup>';
    } else if(exponentFormat === 'B' && exponent === 9) {
        v += 'B';
    } else if(isSIFormat(exponentFormat)) {
        v += SIPREFIXES[exponent / 3 + 5];
    }
}
```

**Exponent Processing Rules:**
1. Skip if `exponentFormat === 'hide'`
2. Fall back to `'power'` format if SI format requested but exponent is beyond SI range
3. Format exponent sign:
   - Negative: use proper minus sign
   - Positive: use `+` for most formats, no sign for `'power'`
4. Apply format-specific suffix:
   - `'e'`/`'E'`: Append format character and signed exponent
   - `'power'`: Append `×10<sup>exponent</sup>`
   - `'B'` with exponent 9: Append `'B'`
   - SI formats: Use prefix from `SIPREFIXES` array

**SI Prefixes Array:**
```javascript
var SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T'];
```
- Index calculation: `exponent / 3 + 5`
- Covers range from 10^-15 (f) to 10^14 (T)
- Beyond this range, falls back to power notation

**SI Range Validation:**
```javascript
function beyondSI(exponent) {
    return exponent > 14 || exponent < -15;
}
```

### 10. Final Sign Application

```javascript
if(isNeg) return MINUS_SIGN + v;
return v;
```

**Final Step:**
- Prepends proper minus sign if original value was negative
- Uses `MINUS_SIGN` constant (proper Unicode minus) rather than hyphen-minus

## Key Dependencies

### External Functions
- **`isNumeric`**: From 'fast-isnumeric' package, tests if value is numeric
- **`autoTickRound`**: Calculates appropriate tick rounding and exponent for an axis
- **`axes.getTickFormat`**: Retrieves tick format string, considering tickformatstops
- **`Lib.numSeparate`**: Applies decimal and thousands separators

### Constants
- **`MINUS_SIGN`**: Proper Unicode minus sign character
- **`SIPREFIXES`**: Array of SI prefix characters

## Edge Cases and Special Behaviors

1. **Zero Values**: Any value smaller than epsilon (10^(-tickRound)/2) becomes "0"
2. **Hover Precision**: Hover mode adds 4 extra digits of precision
3. **SI Range Limits**: Exponents beyond ±15 fall back to power notation
4. **B vs G**: Format 'B' uses 'B' for 10^9 instead of 'G' (billions vs giga)
5. **Year Handling**: 4-digit integers aren't separated unless explicitly enabled
6. **Custom Formats**: tickformat overrides all other formatting logic
7. **Sign Preservation**: Uses proper Unicode minus signs for negative values

## Implementation Notes for Replication

1. The epsilon addition (`v += e`) is crucial for proper rounding behavior
2. The order of operations matters: exponent scaling must occur before precision rounding
3. The `tickRound` adjustment when exponent is applied ensures consistent decimal precision
4. SI prefix indexing uses integer division: `SIPREFIXES[exponent / 3 + 5]`
5. The zero case must reset the `isNeg` flag to prevent "-0" display
6. Hover mode creates a temporary axis configuration to calculate precision independently