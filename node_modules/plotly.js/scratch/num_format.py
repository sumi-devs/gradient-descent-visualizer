#!/usr/bin/env python3
"""
Python implementation of Plotly.js numFormat function.

This module provides a faithful Python translation of the numFormat function 
from src/plots/cartesian/axes.js, maintaining the same logic and behavior.

Key features implemented:
- All exponent format types (e, E, SI, B, power, none, hide)
- Precision rounding with positive, zero, and negative tick rounding
- SI prefix handling with proper range validation
- Thousands separator and decimal point formatting
- Hover mode with increased precision
- Proper Unicode minus sign handling
- Zero threshold (epsilon) handling

Limitations of this implementation:
- Custom tick format support is simplified (doesn't use D3 formatting)
- autoTickRound function is simplified compared to the full Plotly.js version
- tickformatstops processing is not implemented in get_tick_format
"""

import re
import math
from typing import Union, Optional, Dict, Any


# Constants
MINUS_SIGN = '−'  # Unicode minus sign (U+2212)
SIPREFIXES = ['f', 'p', 'n', 'μ', 'm', '', 'k', 'M', 'G', 'T']
SI_INDEX_OFFSET = 5
SI_MAX_EXP = 14
SI_MIN_EXP = -15


def is_numeric(value):
    """Check if a value is numeric (equivalent to fast-isnumeric)."""
    try:
        num = float(value)
        return not math.isnan(num)
    except (ValueError, TypeError):
        return False


def is_si_format(exponent_format):
    """Check if exponent format is B."""
    return exponent_format == 'B'


def beyond_si(exponent):
    """Check if exponent is beyond SI prefix range."""
    return exponent > SI_MAX_EXP or exponent < SI_MIN_EXP


def num_separate(value, separators, separate_thousands=False):
    """
    Apply decimal and thousands separators to a number string.
    
    Args:
        value: Number as string
        separators: String where first char is decimal sep, second is thousands sep
        separate_thousands: Whether to separate thousands for 4-digit integers
    
    Returns:
        Formatted string with separators applied
    """
    if not isinstance(separators, str) or len(separators) == 0:
        raise ValueError('Separator string required for formatting!')
    
    if isinstance(value, (int, float)):
        value = str(value)
    
    decimal_sep = separators[0] if separators else '.'
    thou_sep = separators[1] if len(separators) > 1 else ''
    
    # Split on decimal point
    parts = value.split('.')
    integer_part = parts[0]
    decimal_part = ('.' + parts[1]) if len(parts) > 1 else ''
    
    # Apply thousands separator
    if thou_sep and (len(parts) > 1 or len(integer_part) > 4 or separate_thousands):
        integer_part = re.sub(r'(\d)(?=(\d{3})+(?!\d))', rf'\1{thou_sep}', integer_part)
    
    # Replace decimal point if needed
    if decimal_part and decimal_sep != '.':
        decimal_part = decimal_sep + decimal_part[1:]
    
    return integer_part + decimal_part


def auto_tick_round(ax_config):
    """
    Calculate tick rounding and exponent for an axis configuration.
    This is a simplified version of the autoTickRound function.
    """
    dtick = ax_config.get('dtick', 1)
    ax_config['_tickexponent'] = 0
    
    if not is_numeric(dtick) and not isinstance(dtick, str):
        dtick = 1
    
    ax_type = ax_config.get('type', 'linear')
    if ax_type in ['category', 'multicategory']:
        ax_config['_tickround'] = None
        return
    
    # Simplified logic - in real implementation this would be more complex
    if isinstance(dtick, str):
        ax_config['_tickround'] = 0
    elif dtick >= 1:
        ax_config['_tickround'] = 0
    else:
        ax_config['_tickround'] = -math.floor(math.log10(dtick))




def apply_rounding(value, tick_round):
    """Apply rounding based on tick_round value."""
    if tick_round == 0:
        return str(int(math.floor(value)))
    elif tick_round < 0:
        rounded = str(int(round(value)))
        return rounded[:len(rounded) + tick_round] + '0' * (-tick_round)
    else:
        value_str = str(value)
        if '.' in value_str:
            dp_pos = value_str.find('.') + 1
            value_str = value_str[:dp_pos + tick_round]
            return re.sub(r'\.?0+$', '', value_str)
        return value_str


def format_exponent(value, exponent, exponent_format):
    """Format a value with its exponent based on the specified format."""
    if not exponent or exponent_format == 'none':
        return value
        
    if exponent_format == 'B':
        if beyond_si(exponent):
            # Fall back to returning unchanged value for out-of-range
            return value
        
        if exponent == 9:
            return value + 'B'
        else:
            # Use SI prefix from array
            prefix_index = exponent // 3 + SI_INDEX_OFFSET
            if 0 <= prefix_index < len(SIPREFIXES):
                return value + SIPREFIXES[prefix_index]
    
    return value


def num_format(
    v: float,
    tickround: int = 0,
    exponentformat: str = 'B',
    tickexponent: int = 0,
    separatethousands: bool = False,
    separators: str = '.,'
) -> str:
    """
    Format a numerical value for display on Plotly.js axes.
    
    Args:
        v: The numerical value to format
        tickround: Number of decimal places (positive), or rounding precision (negative/zero)
        exponentformat: Format for exponents ('B' or 'none')
        tickexponent: Exponent to apply for scaling (enables SI prefixes)
        separatethousands: Whether to add thousands separators
        separators: String with decimal separator (pos 0) and thousands separator (pos 1)
    
    Returns:
        Formatted number as string ready for display
    """
    # 1. Initial setup and parameter extraction
    is_neg = v < 0
    
    # 3. Epsilon calculation and near-zero handling
    epsilon = math.pow(10, -tickround) / 2 if tickround is not None else 0.5
    
    if abs(v) < epsilon:
        v = '0'
        is_neg = False
        tickexponent = 0  # Zero should not have exponent formatting
    else:
        # 4. Exponent format processing
        if exponentformat == 'none':
            tickexponent = 0
        
        # 5. Main number processing (non-zero values)
        v = abs(v)
        v += epsilon  # Add epsilon for proper rounding
        
        # Apply exponent scaling
        if tickexponent:
            v *= math.pow(10, -tickexponent)
            tickround += tickexponent
        
        # 6. Precision rounding logic
        v = apply_rounding(v, tickround)
        
        # 7. Thousands separator application
        v = num_separate(v, separators, separatethousands)
    
    # 8. Exponent formatting application
    v = format_exponent(v, tickexponent, exponentformat)
    
    # 9. Final sign application
    if is_neg:
        return f'{MINUS_SIGN}{v}'
    return v


# Example usage and test cases
if __name__ == '__main__':
    print("Testing numFormat function:")
    
    print("\nBasic formatting:")
    print(f"1234.567 -> {num_format(1234.567, tickround=2, separatethousands=True)}")
    print(f"0.001234 -> {num_format(0.001234, tickround=2, separatethousands=True)}")
    print(f"1000000 -> {num_format(1000000, tickround=2, separatethousands=True)}")
    print(f"-42.0 -> {num_format(-42.0, tickround=2, separatethousands=True)}")
    
    # Test with exponents
    print("\nWith SI exponents:")
    print(f"1234567 with exp 3 -> {num_format(1234567, tickround=2, tickexponent=3, separatethousands=True)}")
    print(f"1234567 with exp 6 -> {num_format(1234567, tickround=2, tickexponent=6, separatethousands=True)}")
    
    # Test different exponent formats
    print("\nDifferent exponent formats:")
    formats = ['B', 'none']
    for fmt in formats:
        result = num_format(1234567, tickround=2, tickexponent=3, exponentformat=fmt, separatethousands=True)
        print(f"Format '{fmt}': {result}")
    
    # Test basic precision
    print("\nBasic precision:")
    print(f"2 decimal places: {num_format(1234.567, tickround=2)}")
    
    # Test negative rounding
    print("\nNegative rounding:")
    print(f"12345 with tickRound -2 -> {num_format(12345, tickround=-2, exponentformat='none')}")
    
    # Test zero handling
    print("\nZero handling:")
    print(f"0 -> {num_format(0, tickround=2, tickexponent=3)}")
    print(f"0.0001 -> {num_format(0.0001, tickround=2, tickexponent=3)}")
    print(f"-0.0001 -> {num_format(-0.0001, tickround=2, tickexponent=3)}")